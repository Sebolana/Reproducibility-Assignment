
---

### 3. `basic_analysis/puzzle15_basic.py`
```python
import numpy as np
import random
import time
from typing import Tuple, List

class Puzzle15:
    def __init__(self, state=None):
        self.size = 4
        self.goal = np.arange(1, 17).reshape(4, 4) % 16
        self.state = self.goal.copy() if state is None else np.array(state)
        
    def shuffle(self, moves: int = 20):
        """Shuffle the puzzle with valid moves starting from solved state"""
        self.state = self.goal.copy()
        for _ in range(moves):
            blank = self.find_blank()
            possible_moves = []
            if blank[0] > 0: possible_moves.append('UP')
            if blank[0] < 3: possible_moves.append('DOWN')
            if blank[1] > 0: possible_moves.append('LEFT')
            if blank[1] < 3: possible_moves.append('RIGHT')
            self.move(random.choice(possible_moves))
    
    def find_blank(self) -> Tuple[int, int]:
        return tuple(np.argwhere(self.state == 0)[0])
    
    def move(self, direction: str) -> bool:
        blank = self.find_blank()
        new_state = self.state.copy()
        
        if direction == 'UP' and blank[0] > 0:
            new_state[blank[0], blank[1]], new_state[blank[0]-1, blank[1]] = \
                new_state[blank[0]-1, blank[1]], new_state[blank[0], blank[1]]
        elif direction == 'DOWN' and blank[0] < 3:
            new_state[blank[0], blank[1]], new_state[blank[0]+1, blank[1]] = \
                new_state[blank[0]+1, blank[1]], new_state[blank[0], blank[1]]
        elif direction == 'LEFT' and blank[1] > 0:
            new_state[blank[0], blank[1]], new_state[blank[0], blank[1]-1] = \
                new_state[blank[0], blank[1]-1], new_state[blank[0], blank[1]]
        elif direction == 'RIGHT' and blank[1] < 3:
            new_state[blank[0], blank[1]], new_state[blank[0], blank[1]+1] = \
                new_state[blank[0], blank[1]+1], new_state[blank[0], blank[1]]
        else:
            return False
        
        self.state = new_state
        return True
    
    def is_solved(self) -> bool:
        return np.array_equal(self.state, self.goal)
    
    def manhattan_distance(self) -> int:
        distance = 0
        for i in range(4):
            for j in range(4):
                val = self.state[i,j]
                if val != 0:
                    target_i, target_j = (val-1) // 4, (val-1) % 4
                    distance += abs(i - target_i) + abs(j - target_j)
        return distance
    
    def is_solvable(self) -> bool:
        flat = [num for row in self.state for num in row]
        inversions = 0
        blank_row = 0
        
        for i in range(len(flat)):
            if flat[i] == 0:
                blank_row = i // 4
                continue
            for j in range(i + 1, len(flat)):
                if flat[j] == 0:
                    continue
                if flat[i] > flat[j]:
                    inversions += 1
        
        blank_row_from_bottom = 4 - blank_row
        return (inversions % 2 == 0) == (blank_row_from_bottom % 2 == 1)

if __name__ == "__main__":
    num_puzzles = 100
    methods = ['15-puzzle', 'random']
    
    for method in methods:
        print(f"\nEvaluating {method} puzzles...")
        puzzles = generate_puzzles(method, num_puzzles)
        results = evaluate_puzzles(puzzles)
        
        print(f"Solvable: {results['solvable']}/{num_puzzles}")
        print(f"Manhattan Distance - Avg: {results['avg_manhattan']:.1f}")
        print("\nExample puzzle:")
        print(puzzles[0].state)
